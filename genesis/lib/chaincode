#!/usr/bin/env bash

set -eu
set -o pipefail

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

. ${SCRIPT_DIR}/setenv
. ${SCRIPT_DIR}/utils

# private variables
__CHAINCODE_SOURCE__=""
__CHAINCODE_PACKAGE__=""

function prompt_chaincode_source {
  log_info "ðŸ‘‰ Enter absolute path to the IoT Blockchain Service project..."
  read __CHAINCODE_SOURCE__
  __CHAINCODE_PACKAGE__=${__CHAINCODE_SOURCE__}/${X_CHAINCODE_NAME}_${X_CHAINCODE_VERSION}.tar.gz
  __CHAINCODE_SOURCE__=${__CHAINCODE_SOURCE__}/chaincode

  if [[ ! -d ${__CHAINCODE_SOURCE__} ]]; then
    log_error "${__CHAINCODE_SOURCE__} does not exist"
    return 1
  fi

}

function package_chaincode {
  log_info "ðŸ‘‰ Packaging chaincode ${X_CHAINCODE_NAME}..."

  pushd ${__CHAINCODE_SOURCE__} > /dev/null
  rm -rf vendor ${X_CHAINCODE_NAME}_*.tar.gz
  GO111MODULE=on go mod vendor
  popd > /dev/null

  peer lifecycle chaincode package \
      ${__CHAINCODE_PACKAGE__} \
      --path ${__CHAINCODE_SOURCE__} \
      --lang golang \
      --label ${X_CHAINCODE_NAME}_${X_CHAINCODE_VERSION}
}

function install_chaincode {
  log_info "ðŸ‘‰ Installing chaincode ${X_CHAINCODE_NAME}..."

  peer lifecycle chaincode install ${__CHAINCODE_PACKAGE__}
}

function approve_chaincode {
  log_info "ðŸ‘‰ Approving chaincode ${X_CHAINCODE_NAME}..."

  local package_id=$(peer lifecycle chaincode queryinstalled |\
      sed -n "/${X_CHAINCODE_NAME}_${X_CHAINCODE_VERSION}/{s/^Package ID: //; s/, Label:.*$//; p;}")

  peer lifecycle chaincode approveformyorg \
      --tls \
      --orderer ${X_ORDERER_HOST}:7050 \
      --ordererTLSHostnameOverride ${X_ORDERER_HOST} \
      --cafile ${X_ORDERER_TLS_DIR}/ca.crt \
      --channelID ${X_FABRIC_CHANNEL} \
      --name ${X_CHAINCODE_NAME} \
      --version ${X_CHAINCODE_VERSION} \
      --sequence ${X_CHAINCODE_SEQUENCE} \
      --package-id ${package_id}
}

function wait_chaincode_approved {
  log_info "ðŸ‘‰ Wait for chaincode ${X_CHAINCODE_NAME} to be approved..."

  while true; do
    sleep 1

    local res=$(peer lifecycle chaincode checkcommitreadiness \
        --channelID ${X_FABRIC_CHANNEL} \
        --name ${X_CHAINCODE_NAME} \
        --version ${X_CHAINCODE_VERSION} \
        --sequence ${X_CHAINCODE_SEQUENCE} \
        --output json)

    local org1_approves=$(echo ${res} | jq .approvals.Org1MSP)
    local org2_approves=$(echo ${res} | jq .approvals.Org2MSP)

    if [[ ${org1_approves} == "true" && ${org2_approves} == "true" ]]; then
      break
    fi
  done
}

function commit_chaincode_definition {
  log_info "ðŸ‘‰ Committing chaincode ${X_CHAINCODE_NAME} definition..."

  peer lifecycle chaincode commit \
      --tls \
      --orderer ${X_ORDERER_HOST}:7050 \
      --ordererTLSHostnameOverride ${X_ORDERER_HOST} \
      --cafile ${X_ORDERER_TLS_DIR}/ca.crt \
      --peerAddresses ${X_ORG1_PEER0_HOST}:7051 \
      --tlsRootCertFiles ${X_ORG1_TLS_DIR}/ca.crt \
      --peerAddresses ${X_ORG2_PEER0_HOST}:7051 \
      --tlsRootCertFiles ${X_ORG2_TLS_DIR}/ca.crt \
      --channelID ${X_FABRIC_CHANNEL} \
      --name ${X_CHAINCODE_NAME} \
      --version ${X_CHAINCODE_VERSION} \
      --sequence ${X_CHAINCODE_SEQUENCE}
}

function wait_chaincode_committed {
  log_info "ðŸ‘‰ Wait for chaincode ${X_CHAINCODE_NAME} definition to be committed..."

  local expected="Version: ${X_CHAINCODE_VERSION}, Sequence: ${X_CHAINCODE_SEQUENCE},"
  expected="${expected} Endorsement Plugin: escc, Validation Plugin: vscc"

  local match="^Version: $X_CHAINCODE_VERSION, Sequence: ${X_CHAINCODE_SEQUENCE},"
  match="${match} Endorsement Plugin: escc, Validation Plugin: vscc"

  while true; do
    sleep 1

    local res=$(peer lifecycle chaincode querycommitted \
        --channelID ${X_FABRIC_CHANNEL} \
        --name ${X_CHAINCODE_NAME} | grep -o "${match}")
  
    if [[ ${expected} == ${res} ]]; then
      break
    fi
  done
}
